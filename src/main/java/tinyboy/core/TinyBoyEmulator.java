package tinyboy.core;

import java.util.function.Function;

import javr.core.AVR;
import javr.core.AVR.HaltedException;
import javr.core.AvrConfiguration;
import javr.core.AvrDecoder;
import javr.core.AvrExecutor;
import javr.core.Wire;
import javr.io.HexFile;
import javr.memory.ByteMemory;
import javr.memory.IoMemory;
import javr.memory.MultiplexedMemory;
import javr.peripherals.DotMatrixDisplay;
import javr.ports.InputOutputPort;
import javr.util.IdealWire;

/**
 * Provides a complete configuration of the simple game console, where inputs
 * are generated by a simulation. The flash memory is also profiled so that we
 * can determine which instructions were accessed during the simulation. Using
 * this information, we can then determine coverage.
 *
 * @author David J. Pearce
 *
 */
public class TinyBoyEmulator {
	public static final int DISPLAY_WIDTH = 80;
	public static final int DISPLAY_HEIGHT = 48;
	/**
	 * The ATtiny85 Microcontroller which underpins the TinyBoy.
	 */
	private final AVR.Instrumentable avr;
	/**
	 * Represents the dot-matrix display on the TinyBoy.
	 */
	private final DotMatrixDisplay display;
	/**
	 * Represents the four directional buttons on the TinyBoy.
	 */
	private final ControlPad pad;

	public TinyBoyEmulator() {
		this(labels -> new IdealWire(labels));
	}

	public TinyBoyEmulator(Function<String[],Wire> factory) {
		// Construct the micro-controller
		this.avr = AvrConfiguration.instantiate("ATtiny85",factory);
		// NOTE: we connect the display MISO and SS to LOW as they are not needed in
		// this design, thereby freeing up pins for the button pad.
		this.display = new DotMatrixDisplay(80, 48,
				new Wire[] { avr.getPin("SCK"), avr.getPin("MOSI"), Wire.LOW, Wire.LOW });
		this.pad = new ControlPad(avr.getPin("PB1"), avr.getPin("PB3"), avr.getPin("PB4"), avr.getPin("PB5"));
	}

	public AVR.Instrumentable getAVR() {
		return avr;
	}

	/**
	 * Get the width of the display in pixels.
	 *
	 * @return
	 */
	public int getDisplayWidth() {
		return DISPLAY_WIDTH;
	}

	/**
	 * Get the height of the display in pixels.
	 *
	 * @return
	 */
	public int getDisplayHeight() {
		return DISPLAY_HEIGHT;
	}

	/**
	 * Check whether a given pixel is set or not.
	 *
	 * @param x
	 * @param y
	 * @return
	 */
	public boolean isPixelSet(int x, int y) {
		return display.isSet(x, y);
	}

	/**
	 * Get the current state of a given button.
	 *
	 * @param button
	 * @return
	 */
	public boolean getButtonState(ControlPad.Button button) {
		return pad.getState(button);
	}

	/**
	 * Set a given button on the tiny boy.
	 *
	 * @param button
	 * @param value
	 */
	public void setButtonState(ControlPad.Button button, boolean value) {
		pad.setState(button, value);
	}

	/**
	 * Reset the TinyBoy.
	 */
	public void reset() {
		avr.reset();
		pad.reset();
		display.reset();
	}

	/**
	 * Upload a new firmware to the tiny boy. This writes the firmware to the flash
	 * memory.
	 *
	 * @param firmware
	 */
	public void upload(HexFile firmware) {
		firmware.uploadTo(avr.getCode());
	}

	/**
	 * Clock peripherals once
	 */
	public void clockPeripherals() {
		display.clock();
		pad.clock();
	}

	/**
	 * Clock the simulation once.
	 * @throws HaltedException
	 */
	public void clock() throws HaltedException {
		clockPeripherals();
		avr.clock();
	}

	/**
	 * Close down the emulator and release any resources (e.g. windows on the screen).
	 */
	public void destroy() {

	}
}

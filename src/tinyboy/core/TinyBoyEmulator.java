package tinyboy.core;

import java.util.BitSet;
import java.util.Iterator;

import javaavr.core.AVR;
import javaavr.core.AvrDecoder;
import javaavr.core.AvrExecutor;
import javaavr.core.Wire;
import javaavr.io.HexFile;
import javaavr.peripherals.DotMatrixDisplay;
import javaavr.peripherals.InputSimulation;
import javaavr.util.ByteMemory;
import javaavr.util.IoMemory;
import javaavr.util.MultiplexedMemory;
import javaavr.util.WireArrayPort;
import tinyboy.util.ProfiledMemory;

/**
 * Provides a complete configuration of the simple game console, where inputs
 * are generated by a simulation. The flash memory is also profiled so that we
 * can determine which instructions were accessed during the simulation. Using
 * this information, we can then determine coverage.
 *
 * @author David J. Pearce
 *
 */
public class TinyBoyEmulator {
	// Port addresses for ATtiny85
	public static final int PINB = 0x16;
	public static final int DDRB = 0x17;
	public static final int PORTB = 0x18;
	// ATtiny85 configuration
	private final Wire[] ioPinWires = new Wire[6];
	private final WireArrayPort port = new WireArrayPort(PORTB, DDRB, PINB, ioPinWires);
	private final AVR.Memory regs = new ByteMemory(32);
	private final AVR.Memory io = new IoMemory(new ByteMemory(64), port);
	private final AVR.Memory SRAM = new ByteMemory(512);
	private final ProfiledMemory flash = new ProfiledMemory(new ByteMemory(8192));
	private final AVR.Memory data = new MultiplexedMemory(regs, io, SRAM);
	private final AVR avr = new AVR(new AvrDecoder(), new AvrExecutor(), flash, data);
	// Peripherals
	private final DotMatrixDisplay display = new DotMatrixDisplay(64, 64);
	private final ButtonPad pad = new ButtonPad();

	public TinyBoyEmulator() {
		// Connect up the display
		Wire[] outputs = display.getWires();
		for (int i = 0; i != outputs.length; ++i) {
			ioPinWires[i] = outputs[i];
		}
		// Connect the input "buttons". Observe that this overwrites the MISO and SS
		// lines, which is fine as these are unused.
		Wire[] inputs = pad.getWires();
		ioPinWires[2] = inputs[0];
		ioPinWires[3] = inputs[1];
		ioPinWires[4] = inputs[2];
		ioPinWires[5] = inputs[3];
	}

	/**
	 * Reset the AVR.
	 */
	public void reset() {
		avr.reset();
	}

	/**
	 * Get the current state of the display.
	 *
	 * @return
	 */
	public String getOutput() {
		return display.toString();
	}

	/**
	 * Set a given button on the tiny boy.
	 *
	 * @param button
	 * @param value
	 */
	public void set(ButtonPad.Button button, boolean value) {
		pad.set(button, value);
	}

	/**
	 * Upload a new firmware to the tiny boy. This writes the firmware to the flash
	 * memory.
	 *
	 * @param firmware
	 */
	public void upload(HexFile firmware) {
		firmware.uploadTo(flash);
	}

	/**
	 * Get the set of instructions which have been covered the simulation.
	 *
	 * @return
	 */
	public BitSet getCoverage() {
		return flash.getReads();
	}

	/**
	 * Clock the simulation once.
	 */
	public void clock() {
		display.clock();
		pad.clock();
		avr.clock();
	}
}

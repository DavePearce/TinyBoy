package tinyboy.core;

import javr.core.AVR;
import javr.core.AvrDecoder;
import javr.core.AvrExecutor;
import javr.core.Wire;
import javr.io.HexFile;
import javr.memory.ByteMemory;
import javr.memory.IoMemory;
import javr.memory.MultiplexedMemory;
import javr.peripherals.DotMatrixDisplay;
import javr.util.IdealWire;
import javr.util.WireArrayPort;

/**
 * Provides a complete configuration of the simple game console, where inputs
 * are generated by a simulation. The flash memory is also profiled so that we
 * can determine which instructions were accessed during the simulation. Using
 * this information, we can then determine coverage.
 *
 * @author David J. Pearce
 *
 */
public class TinyBoyEmulator {
	/**
	 * The ATtiny85 Microcontroller which underpins the TinyBoy.
	 */
	private final AVR.Instrumentable avr;
	/**
	 * Represents the dot-matrix display on the TinyBoy.
	 */
	private final DotMatrixDisplay display;
	/**
	 * Represents the four directional buttons on the TinyBoy.
	 */
	private final ControlPad pad;

	public TinyBoyEmulator() {
		// Construct the micro-controller
		this.avr = constructATtiny85();
		// Construct and connect components
		Wire[] pins = avr.getPins();
		// NOTE: we connect the display MISO and SS to LOW as they are not needed in
		// this design, thereby freeing up pins for the button pad.
		this.display = new DotMatrixDisplay(64, 64, new Wire[] { pins[1], pins[2], Wire.LOW, Wire.LOW });
		this.pad = new ControlPad(pins[3],pins[4],pins[5],pins[6]);
	}

	public AVR.Instrumentable getAVR() {
		return avr;
	}

	/**
	 * Get the width of the display in pixels.
	 *
	 * @return
	 */
	public int getDisplayWidth() {
		return 64;
	}

	/**
	 * Get the height of the display in pixels.
	 *
	 * @return
	 */
	public int getDisplayHeight() {
		return 64;
	}

	/**
	 * Check whether a given pixel is set or not.
	 *
	 * @param x
	 * @param y
	 * @return
	 */
	public boolean isPixelSet(int x, int y) {
		return display.isSet(x, y);
	}

	/**
	 * Get the current state of a given button.
	 *
	 * @param button
	 * @return
	 */
	public boolean getButtonState(ControlPad.Button button) {
		return pad.getState(button);
	}

	/**
	 * Set a given button on the tiny boy.
	 *
	 * @param button
	 * @param value
	 */
	public void setButtonState(ControlPad.Button button, boolean value) {
		pad.setState(button, value);
	}

	/**
	 * Reset the TinyBoy.
	 */
	public void reset() {
		avr.reset();
		pad.reset();
		display.reset();
	}

	/**
	 * Upload a new firmware to the tiny boy. This writes the firmware to the flash
	 * memory.
	 *
	 * @param firmware
	 */
	public void upload(HexFile firmware) {
		firmware.uploadTo(avr.getCode());
	}

	/**
	 * Clock the simulation once.
	 */
	public void clock() {
		display.clock();
		pad.clock();
		avr.clock();
	}

	/**
	 * Construct an AVR instance representing the ATtiny85. This needs to be
	 * instrumentable so that we can add hooks for coverage testing, etc.
	 *
	 * @return
	 */
	public AVR.Instrumentable constructATtiny85() {
		// This is the configuration for an ATTiny85.
		final int PINB = 0x16;
		final int DDRB = 0x17;
		final int PORTB = 0x18;
		// ATtiny has 8 pins.
		Wire[] pins = new Wire[] { new IdealWire("+5V"), new IdealWire("PB0"), new IdealWire("PB1"),
				new IdealWire("PB2"), new IdealWire("PB3"), new IdealWire("PB4"), new IdealWire("PB5"),
				new IdealWire("GND") };
		// ATtiny has a single port
		WireArrayPort port = new WireArrayPort(PORTB, DDRB, PINB, pins[1], pins[2], pins[3], pins[4], pins[5], pins[6]);
		// ATtiny has 32 general purpose registers.
		AVR.Memory registers = new ByteMemory(32);
		// ATtiny has 64 io registers
		AVR.Memory io = new IoMemory(new ByteMemory(64), port);
		// ATtiny has 512 bytes of SRAM
		AVR.Memory SRAM = new ByteMemory(512);
		// ATtiny has 8K programmable flash.
		AVR.Memory flash = new ByteMemory(8192);
		// Multiplex it all together.
		AVR.Memory data = new MultiplexedMemory(registers, io, SRAM);
		//
		return new AVR.Instrumentable(new AvrExecutor(flash.size(),new AvrDecoder()), pins, flash, data);
	}
}
